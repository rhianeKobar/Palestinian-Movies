"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyHooks = exports.AsyncHooks = void 0;
const sort_js_1 = require("./sort.js");
const isDev = process.env.GRAPHILE_ENV === "development";
class AsyncHooks {
    constructor() {
        this.callbacks = Object.create(null);
    }
    hook(event, fn) {
        this.callbacks[event] = this.callbacks[event] || [];
        this.callbacks[event].push(fn);
    }
    /**
     * Hooks can _mutate_ the argument, they cannot return a replacement. This
     * allows us to completely side-step the problem of recursive calls.
     */
    process(event, ...args) {
        const callbacks = this.callbacks[event];
        if (!callbacks) {
            return;
        }
        const l = callbacks.length;
        let chain = undefined;
        for (let i = 0; i < l; i++) {
            const callback = callbacks[i];
            if (chain !== undefined) {
                chain = chain.then(() => callback.apply(null, args));
            }
            else {
                const result = callback.apply(null, args);
                if (result != null) {
                    if (isDev && typeof result.then !== "function") {
                        throw new Error(`Hook '${event}' returned invalid value of type ${typeof result} - must be 'undefined' or a Promise/PromiseLike.`);
                    }
                    chain = result;
                }
            }
        }
        return chain;
    }
}
exports.AsyncHooks = AsyncHooks;
function applyHooks(plugins, hooksRetriever, applyHookCallback) {
    // Normalize all the hooks and gather them into collections
    const allHooks = Object.create(null);
    let uid = 0;
    if (plugins) {
        for (const plugin of plugins) {
            const hooks = hooksRetriever(plugin);
            if (!hooks) {
                continue;
            }
            const keys = Object.keys(hooks);
            for (const key of keys) {
                const hookSpecRaw = hooks[key];
                if (!hookSpecRaw) {
                    continue;
                }
                // TypeScript nonsense
                const isPluginHookObject = (v) => typeof v !== "function";
                const isPluginHookFunction = (v) => typeof v === "function";
                const callback = (isPluginHookFunction(hookSpecRaw) ? hookSpecRaw : hookSpecRaw.callback);
                const { provides, before, after } = isPluginHookObject(hookSpecRaw)
                    ? hookSpecRaw
                    : {};
                if (!allHooks[key]) {
                    allHooks[key] = [];
                }
                // We need to give each hook a unique ID
                const id = String(uid++);
                allHooks[key].push({
                    id,
                    plugin,
                    callback,
                    provides: [...(provides || []), id, plugin.name],
                    before: before || [],
                    after: after || [],
                });
            }
        }
    }
    // Sort the collections according to provides, before and after.
    for (const hookName in allHooks) {
        const hooks = allHooks[hookName];
        if (!hooks) {
            continue;
        }
        const final = (0, sort_js_1.sortWithBeforeAfterProvides)(hooks, "id");
        // Finally we can register the hooks
        for (const hook of final) {
            applyHookCallback(hookName, hook.callback, hook.plugin);
        }
    }
}
exports.applyHooks = applyHooks;
//# sourceMappingURL=hooks.js.map