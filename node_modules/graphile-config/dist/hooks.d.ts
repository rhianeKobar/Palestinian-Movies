import type { PluginHook } from "./interfaces.js";
export type HookObject<T> = Record<keyof T, PluginHook<(...args: any[]) => any>>;
export declare class AsyncHooks<THooks extends HookObject<THooks>> {
    callbacks: {
        [key in keyof THooks]?: Array<THooks[keyof THooks] extends PluginHook<infer U> ? U : never>;
    };
    hook<THookName extends keyof THooks>(event: THookName, fn: THooks[THookName] extends PluginHook<infer U> ? U : never): void;
    /**
     * Hooks can _mutate_ the argument, they cannot return a replacement. This
     * allows us to completely side-step the problem of recursive calls.
     */
    process<THookName extends keyof THooks>(event: THookName, ...args: Parameters<THooks[THookName] extends PluginHook<infer U> ? U : never>): void | Promise<void>;
}
export declare function applyHooks<THooks extends HookObject<THooks>>(plugins: readonly GraphileConfig.Plugin[] | undefined, hooksRetriever: (plugin: GraphileConfig.Plugin) => Partial<THooks> | undefined, applyHookCallback: <THookName extends keyof THooks>(hookName: THookName, hookFn: THooks[THookName] extends PluginHook<infer U> ? U : never, plugin: GraphileConfig.Plugin) => void): void;
//# sourceMappingURL=hooks.d.ts.map